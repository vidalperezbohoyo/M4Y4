// Code generated by Icestudio 0.10-rc1

`default_nettype none

//---- Top entity
module main #(
 parameter v6e1c38 = 1,
 parameter vbc0bbc = 0,
 parameter vaa0be7 = "vaa0be7.list",
 parameter v7090a7 = "v7090a7.list",
 parameter vab79aa = "vab79aa.list",
 parameter v9eebc3 = "v9eebc3.list"
) (
 input vclk,
 output v06e9b7,
 output vc16043,
 output v2ff3d8,
 output v3fa45d,
 output v3a1698,
 output v680eee,
 output v59bc8e,
 output v20f3ff,
 output v67ba1a,
 output v199360,
 output va2e0dd,
 output v315fec,
 output [0:7] vinit
);
 localparam p1 = vbc0bbc;
 localparam p3 = v6e1c38;
 localparam p13 = v7090a7;
 localparam p14 = vaa0be7;
 localparam p22 = v9eebc3;
 localparam p24 = vab79aa;
 wire [0:7] w0;
 wire w2;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire [0:7] w11;
 wire [0:7] w12;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire [0:7] w21;
 wire [0:7] w23;
 wire w25;
 wire w26;
 wire w27;
 wire w28;
 wire w29;
 wire w30;
 wire w31;
 wire w32;
 wire w33;
 wire w34;
 wire w35;
 wire w36;
 wire [0:1] w37;
 wire [0:1] w38;
 wire [0:3] w39;
 wire [0:2] w40;
 wire w41;
 wire [0:1] w42;
 wire [0:1] w43;
 wire [0:3] w44;
 wire w45;
 wire [0:3] w46;
 wire [0:2] w47;
 wire [0:3] w48;
 wire [0:3] w49;
 wire [0:3] w50;
 wire [0:3] w51;
 wire [0:3] w52;
 wire [0:3] w53;
 wire [0:3] w54;
 wire [0:3] w55;
 wire [0:2] w56;
 wire w57;
 wire [0:3] w58;
 wire [0:2] w59;
 wire w60;
 wire w61;
 wire w62;
 wire w63;
 wire w64;
 wire w65;
 wire w66;
 wire w67;
 assign v06e9b7 = w5;
 assign v2ff3d8 = w6;
 assign v3a1698 = w7;
 assign v59bc8e = w8;
 assign v67ba1a = w9;
 assign va2e0dd = w10;
 assign vc16043 = w15;
 assign v3fa45d = w16;
 assign v680eee = w17;
 assign v20f3ff = w18;
 assign v199360 = w19;
 assign v315fec = w20;
 assign w25 = vclk;
 assign w26 = vclk;
 assign w27 = vclk;
 assign w28 = vclk;
 assign w29 = vclk;
 assign w30 = vclk;
 assign w31 = vclk;
 assign w32 = vclk;
 assign w33 = vclk;
 assign w34 = vclk;
 assign w35 = vclk;
 assign w26 = w25;
 assign w27 = w25;
 assign w27 = w26;
 assign w28 = w25;
 assign w28 = w26;
 assign w28 = w27;
 assign w29 = w25;
 assign w29 = w26;
 assign w29 = w27;
 assign w29 = w28;
 assign w30 = w25;
 assign w30 = w26;
 assign w30 = w27;
 assign w30 = w28;
 assign w30 = w29;
 assign w31 = w25;
 assign w31 = w26;
 assign w31 = w27;
 assign w31 = w28;
 assign w31 = w29;
 assign w31 = w30;
 assign w32 = w25;
 assign w32 = w26;
 assign w32 = w27;
 assign w32 = w28;
 assign w32 = w29;
 assign w32 = w30;
 assign w32 = w31;
 assign w33 = w25;
 assign w33 = w26;
 assign w33 = w27;
 assign w33 = w28;
 assign w33 = w29;
 assign w33 = w30;
 assign w33 = w31;
 assign w33 = w32;
 assign w34 = w25;
 assign w34 = w26;
 assign w34 = w27;
 assign w34 = w28;
 assign w34 = w29;
 assign w34 = w30;
 assign w34 = w31;
 assign w34 = w32;
 assign w34 = w33;
 assign w35 = w25;
 assign w35 = w26;
 assign w35 = w27;
 assign w35 = w28;
 assign w35 = w29;
 assign w35 = w30;
 assign w35 = w31;
 assign w35 = w32;
 assign w35 = w33;
 assign w35 = w34;
 assign w38 = w37;
 assign w43 = w42;
 assign w49 = w48;
 assign w50 = w48;
 assign w50 = w49;
 assign w51 = w48;
 assign w51 = w49;
 assign w51 = w50;
 assign w52 = w48;
 assign w52 = w49;
 assign w52 = w50;
 assign w52 = w51;
 assign w53 = w48;
 assign w53 = w49;
 assign w53 = w50;
 assign w53 = w51;
 assign w53 = w52;
 assign w54 = w48;
 assign w54 = w49;
 assign w54 = w50;
 assign w54 = w51;
 assign w54 = w52;
 assign w54 = w53;
 assign w55 = w48;
 assign w55 = w49;
 assign w55 = w50;
 assign w55 = w51;
 assign w55 = w52;
 assign w55 = w53;
 assign w55 = w54;
 vb717c8 v6d4411 (
  .vcc8c7c(w0),
  .v9e11d8(w37),
  .v7e15b2(w42),
  .v75197e(w48)
 );
 vb9ce14 va82d96 (
  .v2d03ef(w0),
  .v7114a9(w25)
 );
 v01f76a v9fcb7d (
  .va25221(w5),
  .v42d916(w6),
  .v258882(w7),
  .vc7d755(w8),
  .v8e5326(w9),
  .vf22350(w10),
  .vd94b05(w11),
  .vd720df(w12),
  .v62ce62(w26),
  .vded3a6(w41),
  .v9c96ea(w57)
 );
 vf05b5a #(
  .v16d6b8(p1)
 ) v6a713d (
  .v18e78c(w2),
  .v320bf6(w37)
 );
 vfa0a5e v5f4467 (
  .v41eb95(w27),
  .va632a5(w44),
  .v565097(w48),
  .vf892a0(w61)
 );
 vfa0a5e v491780 (
  .v41eb95(w28),
  .va632a5(w39),
  .v565097(w49),
  .vf892a0(w62)
 );
 vfa0a5e v06be19 (
  .v41eb95(w29),
  .v565097(w55),
  .vf892a0(w66)
 );
 vfa0a5e vd3d6e9 (
  .v41eb95(w30),
  .va632a5(w46),
  .v565097(w51),
  .vf892a0(w60)
 );
 vfa0a5e v8c2d70 (
  .v41eb95(w31),
  .v565097(w54),
  .vf892a0(w64)
 );
 vfa0a5e ve80146 (
  .v41eb95(w32),
  .v565097(w50),
  .va632a5(w58),
  .vf892a0(w63)
 );
 vfa0a5e v914d0d (
  .v41eb95(w33),
  .v565097(w52),
  .vf892a0(w65)
 );
 vfa0a5e v853f0b (
  .v41eb95(w34),
  .v565097(w53),
  .vf892a0(w67)
 );
 v9d1e02 vba1673 (
  .v27dec4(w2),
  .vdd3098(w42),
  .ve48246(w60),
  .vd53c9c(w61),
  .v8b3e73(w62),
  .v030ad0(w63)
 );
 vf05b5a #(
  .v16d6b8(p3)
 ) v85f66e (
  .v18e78c(w4),
  .v320bf6(w38)
 );
 v9d1e02 v02bbff (
  .v27dec4(w4),
  .vdd3098(w43),
  .ve48246(w64),
  .v8b3e73(w65),
  .v030ad0(w66),
  .vd53c9c(w67)
 );
 v0fa073 v263c78 (
  .v3f8943(w41),
  .v5ab9a6(w44),
  .vacdbb0(w47)
 );
 v0fa073 v66c62b (
  .v3f8943(w57),
  .v5ab9a6(w58),
  .vacdbb0(w59)
 );
 v2a562b #(
  .vb36a78(p13)
 ) va63429 (
  .vfde47f(w11),
  .v851180(w47)
 );
 v2a562b #(
  .vb36a78(p14)
 ) v35df5a (
  .vfde47f(w12),
  .v851180(w59)
 );
 v0fa073 v92e6cd (
  .v3f8943(w36),
  .v5ab9a6(w39),
  .vacdbb0(w40)
 );
 v0fa073 v2f167e (
  .v3f8943(w45),
  .v5ab9a6(w46),
  .vacdbb0(w56)
 );
 v01f76a v6b7d7d (
  .va25221(w15),
  .v42d916(w16),
  .v258882(w17),
  .vc7d755(w18),
  .v8e5326(w19),
  .vf22350(w20),
  .vd94b05(w21),
  .vd720df(w23),
  .v62ce62(w35),
  .vded3a6(w36),
  .v9c96ea(w45)
 );
 v2a562b #(
  .vb36a78(p22)
 ) v0208f3 (
  .vfde47f(w21),
  .v851180(w40)
 );
 v2a562b #(
  .vb36a78(p24)
 ) v4a89f2 (
  .vfde47f(w23),
  .v851180(w56)
 );
 assign vinit = 8'b00000000;
endmodule

//---------------------------------------------------
//-- Protocol V1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Extract information from the given byte following the communication format
//---------------------------------------------------
//---- Top entity
module vb717c8 (
 input [7:0] vcc8c7c,
 output [1:0] v9e11d8,
 output [1:0] v7e15b2,
 output [3:0] v75197e
);
 wire [0:7] w0;
 wire [0:1] w1;
 wire [0:1] w2;
 wire [0:3] w3;
 assign w0 = vcc8c7c;
 assign v9e11d8 = w1;
 assign v7e15b2 = w2;
 assign v75197e = w3;
 vb717c8_v9a2a06 v9a2a06 (
  .i(w0),
  .m(w1),
  .id(w2),
  .val(w3)
 );
endmodule

//---------------------------------------------------
//-- Protocol Splitter
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Convert input byte to protocol params
//---------------------------------------------------

module vb717c8_v9a2a06 (
 input [7:0] i,
 output [1:0] m,
 output [1:0] id,
 output [3:0] val
);
 assign m = i[7:6];
 assign id = i[5:4];
 assign val = i[3:0];
endmodule
//---- Top entity
module vb9ce14 #(
 parameter v47d474 = 115200
) (
 input v7114a9,
 input v6a1cbe,
 output [7:0] v2d03ef,
 output ve77bd8,
 output v6a2ebd
);
 localparam p4 = v47d474;
 wire w0;
 wire w1;
 wire [0:7] w2;
 wire w3;
 wire w5;
 assign w0 = v7114a9;
 assign w1 = v6a1cbe;
 assign v2d03ef = w2;
 assign v6a2ebd = w3;
 assign ve77bd8 = w5;
 vb9ce14_vf55761 #(
  .BAUD(p4)
 ) vf55761 (
  .clk(w0),
  .RX(w1),
  .data(w2),
  .rcv(w3),
  .busy(w5)
 );
endmodule

//---------------------------------------------------
//-- Serial-rx
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Receptor serie asíncrono. Velocidad por defecto: 115200 baudios
//---------------------------------------------------

module vb9ce14_vf55761 #(
 parameter BAUD = 0
) (
 input clk,
 input RX,
 output [7:0] data,
 output busy,
 output rcv
);
 //-- Constantes para obtener las velocidades estándares
 `define B115200 104 
 `define B57600  208
 `define B38400  313
 `define B19200  625
 `define B9600   1250
 `define B4800   2500
 `define B2400   5000
 `define B1200   10000
 `define B600    20000
 `define B300    40000
 
 //-- Constante para calcular los baudios
 localparam BAUDRATE = (BAUD==115200) ? `B115200 : //-- OK
                       (BAUD==57600)  ? `B57600  : //-- OK
                       (BAUD==38400)  ? `B38400  : //-- Ok
                       (BAUD==19200)  ? `B19200  : //-- OK
                       (BAUD==9600)   ? `B9600   : //-- OK
                       (BAUD==4800)   ? `B4800   : //-- OK 
                       (BAUD==2400)   ? `B2400   : //-- OK
                       (BAUD==1200)   ? `B1200   : //-- OK
                       (BAUD==600)    ? `B600    : //-- OK
                       (BAUD==300)    ? `B300    : //-- OK
                       `B115200 ;  //-- Por defecto 115200 baudios
 
 
 
 
 //-- Calcular el numero de bits para almacenar el divisor
 localparam N = $clog2(BAUDRATE);
 
 // Sincronizacion. Evitar 
 // problema de la metaestabilidad
 
 reg d1;
 reg din;
 
 always @(posedge clk)
  d1 <= RX;
  
 //-- Din contiene el dato serie de entrada listo para usarse   
 always @(posedge clk)
   din <= d1;
   
 //------ Detectar el bit de start: flanco de bajada en din
 
 //-- Registro temporal
 reg q_t0 = 0;
 
 always @(posedge clk)
   q_t0 <= din;
   
 //-- El cable din_fe es un "tic" que aparece cuando llega el flanco de 
 //-- bajada
 wire din_fe = (q_t0 & ~din);
 
 //-------- ESTADO DEL RECEPTOR
 
 //-- 0: Apagado. Esperando
 //-- 1: Encendido. Activo. Recibiendo dato
 reg state = 0;
 
 always @(posedge clk)
   //-- Se pasa al estado activo al detectar el flanco de bajada
   //-- del bit de start
   if (din_fe)
     state <= 1'b1;
     
   //-- Se pasa al estado inactivo al detectar la señal rst_state    
   else if (rst_state)
     state<=1'b0;
 
 //------------------ GENERADOR DE BAUDIOS -----------------------------
 //-- Se activa cuando el receptor está encendido
 
 
 //-- Calcular la mitad del divisor BAUDRATE/2
 localparam BAUD2 = (BAUDRATE >> 1);
 
 //-- Contador del sistema, para esperar un tiempo de  
 //-- medio bit (BAUD2)
 
 //-- NOTA: podria tener N-2 bits en principio
 reg [N-1: 0] div2counter = 0;
 
 //-- Se genera primero un retraso de BAUD/2
 //-- El proceso comienza cuando el estado pasa a 1
 
 always @(posedge clk)
 
   //-- Contar
   if (state) begin
     //-- Solo cuenta hasta BAUD2, luego  
     //-- se queda en ese valor hasta que
     //-- ena se desactiva
     if (div2counter < BAUD2) 
       div2counter <= div2counter + 1;
   end else
     div2counter <= 0;
 
 //-- Habilitar el generador de baudios principal
 //-- cuando termine este primer contador
 wire ena2 = (div2counter == BAUD2);
 
 
 //------ GENERADOR DE BAUDIOS PRINCIPAL
 
 //-- Contador para implementar el divisor
 //-- Es un contador modulo BAUDRATE
 reg [N-1:0] divcounter = 0;
 
 //-- Cable de reset para el contador
 wire reset;
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 //-- Esta señal contiene el tic
 wire ov = (divcounter == BAUDRATE-1);
 
 //-- Comparador que resetea el contador cuando se alcanza el tope
 assign reset = ov | (ena2 == 0);
 
 //-- El cable con el tic para capturar cada bit lo llamamos
 //-- bit_tic, y es la señal de overflow del contador
 wire bit_tic = ov;
 
 //-------- REGISTRO DE DESPLAZAMIENTO -----------
 //-- Es el componente que pasa los bits recibidos a paralelo
 //-- La señal de desplazamiento usada es bit_tic, pero sólo cuando  
 //-- estamos en estado de encendido (state==1)
 //-- Es un registro de 9 bits: 8 bits de datos + bit de stop
 //-- El bit de start no se almacena, es el que ha servido para
 //-- arrancar el receptor
 
 reg [8:0] sr = 0;
 
 always @(posedge clk)
   //-- Se captura el bit cuando llega y el receptor
   //-- esta activado
   if (bit_tic & state)
     sr <= {din, sr[8:1]};
     
 //-- El dato recibido se encuentran en los 8 bits menos significativos
 //-- una vez recibidos los 9 bits
 
 //-------- CONTADOR de bits recibidos
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [4:0] cont = 0;
 
 always @(posedge clk)
 
   //-- El contador se pone a 0 si hay un overflow o 
   //-- el receptor está apagado 
   if ((state==0)| ov2)
     cont <= 0;
   else
     //-- Receptor activado: Si llega un bit se incrementa
     if (bit_tic)
       cont <= cont + 1;
       
 //-- Comprobar overflow
 wire ov2 = (cont == 9);
     
 //-- Esta señal de overflow indica el final de la recepción
 wire fin = ov2;
 
 //-- Se conecta al reset el biestable de estado
 wire rst_state = fin;
 
 //----- REGISTRO DE DATOS -------------------
 //-- Registro de 8 bits que almacena el dato final
 
 //-- Bus de salida con el dato recibido
 reg data = 0;
 
 always @(posedge clk)
 
   //-- Si se ha recibido el ultimo bit, capturamos el dato
   //-- que se encuentra en los 8 bits de menor peso del
   //-- registro de desplazamiento
   if (fin)
     data <= sr[7:0];
 
 //-- Comunicar que se ha recibido un dato
 //-- Tic de dato recibido
 reg rcv = 0;
 always @(posedge clk)
   rcv <= fin;
 
 //-- La señal de busy es directamente el estado del receptor
 assign busy = state;
 
 
endmodule
//---- Top entity
module v01f76a #(
 parameter vcb6012 = 100
) (
 input v62ce62,
 input [7:0] vd94b05,
 input [7:0] vd720df,
 input vded3a6,
 input v9c96ea,
 output va25221,
 output v42d916,
 output v258882,
 output vc7d755,
 output v8e5326,
 output vf22350
);
 localparam p9 = vcb6012;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire [0:7] w6;
 wire w7;
 wire w8;
 wire w10;
 wire [0:7] w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 assign vc7d755 = w0;
 assign w1 = vded3a6;
 assign v258882 = w2;
 assign w2 = vded3a6;
 assign vf22350 = w3;
 assign w4 = v9c96ea;
 assign w5 = v9c96ea;
 assign v8e5326 = w5;
 assign w6 = vd94b05;
 assign va25221 = w7;
 assign w11 = vd720df;
 assign v42d916 = w12;
 assign w13 = v62ce62;
 assign w14 = v62ce62;
 assign w15 = v62ce62;
 assign w2 = w1;
 assign w5 = w4;
 assign w10 = w8;
 assign w14 = w13;
 assign w15 = w13;
 assign w15 = w14;
 v3676a0 v97019e (
  .vcbab45(w0),
  .v0e28cb(w1)
 );
 v3676a0 v0b42df (
  .vcbab45(w3),
  .v0e28cb(w4)
 );
 v6b9ecc v83319c (
  .v676bcb(w6),
  .vdec06b(w7),
  .vc03fca(w8),
  .v8d0ca6(w13)
 );
 v0e64bc #(
  .v207e0d(p9)
 ) ve1ab87 (
  .v8337bc(w8),
  .v531e20(w14)
 );
 v6b9ecc vfd10af (
  .vc03fca(w10),
  .v676bcb(w11),
  .vdec06b(w12),
  .v8d0ca6(w15)
 );
endmodule

//---------------------------------------------------
//-- pwm-2bits CLONE
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Señal pwm de 2 bits (4 niveles)
//---------------------------------------------------
//---- Top entity
module v3676a0 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v3676a0_vd54ca1 vd54ca1 (
  .a(w0),
  .q(w1)
 );
endmodule

//---------------------------------------------------
//-- NOT
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- NOT gate (Verilog implementation)
//---------------------------------------------------

module v3676a0_vd54ca1 (
 input a,
 output q
);
 //-- NOT Gate
 assign q = ~a;
 
 
endmodule
//---- Top entity
module v6b9ecc #(
 parameter v103dea = 0
) (
 input v8d0ca6,
 input [7:0] v676bcb,
 input vc03fca,
 output vdec06b
);
 localparam p3 = v103dea;
 wire w0;
 wire w1;
 wire w2;
 wire [0:7] w4;
 assign w0 = v8d0ca6;
 assign w1 = vc03fca;
 assign vdec06b = w2;
 assign w4 = v676bcb;
 v6b9ecc_vfd72d5 #(
  .P(p3)
 ) vfd72d5 (
  .clk(w0),
  .write(w1),
  .pwm(w2),
  .w(w4)
 );
endmodule

//---------------------------------------------------
//-- pwm-8bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Señal pwm de 8 bits (256 niveles)
//---------------------------------------------------

module v6b9ecc_vfd72d5 #(
 parameter P = 0
) (
 input clk,
 input [7:0] w,
 input write,
 output pwm
);
 //-- Parámetro P: Número de bits del prescaler
 //-- (P = 0 para no usar prescaler)
 
 //-- Bits para el nivel
 localparam N = 8;
 
 //-- Contador principal
 //-- Tamaño: Bits anchura + Prescaler (P)
 localparam C = N + P;
 
 reg [C-1:0] counter = 0;
 always @(posedge clk)
   counter <= counter + 1;
 
 //-- Detectar el comienzo de un ciclo nuevo:
 //-- cuando hay un flanco de bajada en el bit de  
 //-- mayor peso (C-1)
 
 reg q = 0;
 always @(posedge clk)
   q <= counter[C-1];
  
 //-- Cuando cycle_begin es 1, indica que comienza
 //-- un nuevo ciclo
 wire cycle_begin = q & ~counter[C-1];
   
 //-- Registro W: Almacena la anchura actual
 reg [N-1:0] reg_w = 0;
 
 always @(posedge clk)
   //-- Se carga en cada nuevo ciclo de pwm
   if (cycle_begin)
     reg_w <= reg_buf;
 
 //-- Registro buffer. Es donde se almacena la anchura
 //-- introducida por el usuario mientras llega un  
 //-- nuevo ciclo de pwm, y se pueda cargar en el  
 //-- registro w
 reg [N-1:0] reg_buf = 0;
 
 always @(posedge clk)
   //-- Se actualiza cuando llega un dato nuevo
   if (write)
     reg_buf <= w;
 
 //-- Salida del pwm: comparador
 wire pwm_t = (counter[C-1:C-N] < w);
 
 reg pwm = 0;
 //-- Registrar la salida del pwm
 always @(posedge clk)
   pwm <= pwm_t;
 
 
endmodule
//---- Top entity
module v0e64bc #(
 parameter v207e0d = 1
) (
 input v531e20,
 output v8337bc
);
 localparam p2 = v207e0d;
 wire w0;
 wire w1;
 assign v8337bc = w0;
 assign w1 = v531e20;
 v0e64bc_v94c6d7 #(
  .HZ(p2)
 ) v94c6d7 (
  .clk_o(w0),
  .clk(w1)
 );
endmodule

//---------------------------------------------------
//-- Corazon_Hz
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Corazon genérico para bombear bits a la frecuencia fijada en Hz (por defecto 1Hz)
//---------------------------------------------------

module v0e64bc_v94c6d7 #(
 parameter HZ = 0
) (
 input clk,
 output clk_o
);
 
 //parameter HZ=1;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000/HZ;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 //-- Temporal clock
 reg clk_t = 0;
 
 //-- Se usa un contador modulo M/2 para luego
 //-- pasarlo por un biestable T y dividir la frecuencia
 //-- entre 2, para que el ciclo de trabajo sea del 50%
 always @(posedge clk)
     if (divcounter == M/2) begin
       clk_t <= 1;
       divcounter = 0;
     end 
     else begin
       divcounter <=  divcounter + 1;
       clk_t = 0;
     end 
   
 reg clk_o = 0;  
     
 //-- Biestable T para obtener ciclo de trabajo del 50%
 always @(posedge clk)
   if (clk_t)
     clk_o <= ~clk_o;
 
endmodule
//---- Top entity
module vf05b5a #(
 parameter v16d6b8 = 0
) (
 input [1:0] v320bf6,
 output v18e78c
);
 localparam p1 = v16d6b8;
 wire w0;
 wire [0:1] w2;
 assign v18e78c = w0;
 assign w2 = v320bf6;
 vf05b5a_vd75681 #(
  .B(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

//---------------------------------------------------
//-- Igual-1-op
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Comparador de igualdad, de un operando de 2 bits
//---------------------------------------------------

module vf05b5a_vd75681 #(
 parameter B = 0
) (
 input [1:0] a,
 output eq
);
 assign eq = (a == B);
endmodule
//---- Top entity
module vfa0a5e #(
 parameter v422d28 = 0
) (
 input v41eb95,
 input [3:0] v565097,
 input vf892a0,
 output [3:0] va632a5
);
 localparam p0 = v422d28;
 wire w1;
 wire w2;
 wire [0:3] w3;
 wire [0:3] w4;
 assign w1 = vf892a0;
 assign w2 = v41eb95;
 assign w3 = v565097;
 assign va632a5 = w4;
 vfa0a5e_v9148cb #(
  .INI(p0)
 ) v9148cb (
  .load(w1),
  .clk(w2),
  .d(w3),
  .q(w4)
 );
endmodule

//---------------------------------------------------
//-- Registro
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Registro de 4 bits
//---------------------------------------------------

module vfa0a5e_v9148cb #(
 parameter INI = 0
) (
 input clk,
 input [3:0] d,
 input load,
 output [3:0] q
);
 localparam N = 4;
 
 reg [N-1:0] q = INI;
 
 always @(posedge clk)
   if (load)
     q <= d;
endmodule
//---- Top entity
module v9d1e02 (
 input v27dec4,
 input [1:0] vdd3098,
 output ve48246,
 output v8b3e73,
 output v030ad0,
 output vd53c9c
);
 wire [0:1] w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 assign w0 = vdd3098;
 assign ve48246 = w2;
 assign v8b3e73 = w3;
 assign v030ad0 = w4;
 assign vd53c9c = w5;
 assign w9 = v27dec4;
 assign w8 = w7;
 v6307bd v1f4fa3 (
  .v27dec4(w1),
  .v030ad0(w2),
  .vd53c9c(w3),
  .vb192d0(w7)
 );
 v6307bd vaaa5ae (
  .v030ad0(w1),
  .vd53c9c(w6),
  .v27dec4(w9),
  .vb192d0(w10)
 );
 v0dbcb9 v3f8f83 (
  .v8b19dd(w0),
  .v64d863(w7),
  .v3f8943(w10)
 );
 v6307bd va8aa75 (
  .v030ad0(w4),
  .vd53c9c(w5),
  .v27dec4(w6),
  .vb192d0(w8)
 );
endmodule

//---------------------------------------------------
//-- DeMux-1-4
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 1-to-4 DeMultplexer (1-bit channels)
//---------------------------------------------------
//---- Top entity
module v6307bd (
 input v27dec4,
 input vb192d0,
 output v030ad0,
 output vd53c9c
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 assign v030ad0 = w0;
 assign vd53c9c = w1;
 assign w3 = v27dec4;
 assign w4 = v27dec4;
 assign w5 = vb192d0;
 assign w6 = vb192d0;
 assign w4 = w3;
 assign w6 = w5;
 vba518e vb523bf (
  .vcbab45(w0),
  .v0e28cb(w3),
  .v3ca442(w6)
 );
 v3676a0 vde5c93 (
  .vcbab45(w2),
  .v0e28cb(w5)
 );
 vba518e vf65161 (
  .vcbab45(w1),
  .v3ca442(w2),
  .v0e28cb(w4)
 );
endmodule

//---------------------------------------------------
//-- DeMux-1-2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 1-to-2 DeMultplexer (1-bit channels)
//---------------------------------------------------
//---- Top entity
module vba518e (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vba518e_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Two bits input And gate
//---------------------------------------------------

module vba518e_vf4938a (
 input a,
 input b,
 output c
);
 //-- AND gate
 //-- Verilog implementation
 
 assign c = a & b;
 
endmodule
//---- Top entity
module v0dbcb9 (
 input [1:0] v8b19dd,
 output v3f8943,
 output v64d863
);
 wire w0;
 wire w1;
 wire [0:1] w2;
 assign v3f8943 = w0;
 assign v64d863 = w1;
 assign w2 = v8b19dd;
 v0dbcb9_v9a2a06 v9a2a06 (
  .o1(w0),
  .o0(w1),
  .i(w2)
 );
endmodule

//---------------------------------------------------
//-- Bus2-Split-all
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Bus2-Split-all: Split the 2-bits bus into two wires
//---------------------------------------------------

module v0dbcb9_v9a2a06 (
 input [1:0] i,
 output o1,
 output o0
);
 assign o1 = i[1];
 assign o0 = i[0];
endmodule
//---- Top entity
module v0fa073 (
 input [3:0] v5ab9a6,
 output v3f8943,
 output [2:0] vacdbb0
);
 wire w0;
 wire [0:2] w1;
 wire [0:3] w2;
 assign v3f8943 = w0;
 assign vacdbb0 = w1;
 assign w2 = v5ab9a6;
 v0fa073_v9a2a06 v9a2a06 (
  .o1(w0),
  .o0(w1),
  .i(w2)
 );
endmodule

//---------------------------------------------------
//-- Bus4-Split-1-3
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Bus4-Split-1-3: Split the 4-bits bus into two: 1-bit and 3-bits buses
//---------------------------------------------------

module v0fa073_v9a2a06 (
 input [3:0] i,
 output o1,
 output [2:0] o0
);
 assign o1 = i[3];
 assign o0 = i[2:0];
endmodule
//---- Top entity
module v2a562b #(
 parameter vb36a78 = "vb36a78.list"
) (
 input [2:0] v851180,
 output [7:0] vfde47f
);
 localparam p0 = vb36a78;
 wire [0:2] w1;
 wire [0:7] w2;
 assign w1 = v851180;
 assign vfde47f = w2;
 v2a562b_v361fe9 #(
  .DATA(p0)
 ) v361fe9 (
  .i(w1),
  .q(w2)
 );
endmodule

//---------------------------------------------------
//-- mi-tabla3-8
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Circuito combinacional de 3 entradas y 8 salidas
//---------------------------------------------------

module v2a562b_v361fe9 #(
 parameter DATA = 0
) (
 input [2:0] i,
 output [7:0] q
);
 
 //-- Bits del bus de entrada
 localparam N = 3;
 
 //-- Bits del bus de salida
 localparam M = 8;
 
 //-- Calcular tamaño de la tabla
 //-- (filas) segun los bits de entrada
 localparam TAM = 2 ** N;
 
 //-- Definición de la tabla
 //-- Tabla de TAM elementos de M bits
 reg [M-1:0] tabla[0:TAM-1];
 
 //-- Read the table
 assign q = tabla[i];
 
 //-- Init table from DATA parameters
 initial begin
   if (DATA) $readmemb(DATA, tabla);
 end
endmodule
