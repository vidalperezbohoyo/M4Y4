// Code generated by Icestudio 0.10-rc1

`default_nettype none

//---- Top entity
module main #(
 parameter vbddec2 = 160,
 parameter v05ce49 = 15,
 parameter vfe0d09 = 5000,
 parameter v556e21 = 1
) (
 input vclk,
 output v2b0563,
 output [0:7] vinit
);
 localparam p2 = vfe0d09;
 localparam p4 = v05ce49;
 localparam p6 = vbddec2;
 localparam p9 = v556e21;
 wire [0:7] w0;
 wire w1;
 wire w3;
 wire [0:7] w5;
 wire [0:7] w7;
 wire w8;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 assign v2b0563 = w11;
 assign w12 = vclk;
 assign w13 = vclk;
 assign w14 = vclk;
 assign w15 = vclk;
 assign w13 = w12;
 assign w14 = w12;
 assign w14 = w13;
 assign w15 = w12;
 assign w15 = w13;
 assign w15 = w14;
 vb0ff9e v2d6b17 (
  .vdd2008(w0),
  .v521369(w8),
  .vb277aa(w10),
  .v52ffe5(w11),
  .v2d4dc0(w12)
 );
 vd1a52e v9ad454 (
  .v9d2a6a(w0),
  .v2d3366(w3),
  .v2a1cbe(w5),
  .v9d7ae8(w7)
 );
 va20433 vea71d2 (
  .vf54559(w1),
  .ve8318d(w3),
  .va4102a(w13)
 );
 v5124df #(
  .v207e0d(p2)
 ) v3d874e (
  .v8337bc(w1),
  .v531e20(w14)
 );
 v5ad97e #(
  .vc5c8ea(p4)
 ) v4ecc34 (
  .v26dbdb(w5)
 );
 v5ad97e #(
  .vc5c8ea(p6)
 ) v874673 (
  .v26dbdb(w7)
 );
 v725b7e vee1f28 (
  .v9fb85f(w8)
 );
 v3046c7 #(
  .vfb06ae(p9)
 ) vc2aaee (
  .v2a8434(w10),
  .vac0eb2(w15)
 );
 assign vinit = 8'b00000000;
endmodule

//---- Top entity
module vb0ff9e #(
 parameter v1b27a8 = 20
) (
 input v2d4dc0,
 input [7:0] vdd2008,
 input vb277aa,
 input v521369,
 output v52ffe5
);
 localparam p5 = v1b27a8;
 wire w0;
 wire w1;
 wire w2;
 wire [0:7] w3;
 wire w4;
 assign v52ffe5 = w0;
 assign w1 = v521369;
 assign w2 = vb277aa;
 assign w3 = vdd2008;
 assign w4 = v2d4dc0;
 vb0ff9e_v3a816b #(
  .MS(p5)
 ) v3a816b (
  .pwm(w0),
  .ena(w1),
  .write(w2),
  .pos(w3),
  .clk(w4)
 );
endmodule

//---------------------------------------------------
//-- ServoPWM-8bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Controlador de servos, de 8 bits. El periodo del PWM por defecto es de 20ms (Futaba 3003)
//---------------------------------------------------

module vb0ff9e_v3a816b #(
 parameter MS = 0
) (
 input clk,
 input [7:0] pos,
 input write,
 input ena,
 output pwm
);
 //--- Registro de posición
 
 reg [7:0] pos_r = 140;
 
 always @(posedge clk)
   if (write)
     pos_r <= pos;
     
     
 //-- Registro de estado
 
 reg state = 0;
 
 always @(posedge clk)
     state <= ena;
     
 //------------------- Temporizador en unidades de 10us
 
 //--------- Biestable de estado
 
 reg state2 = 0;
 
 wire rst;
 
 always @(posedge clk)
   if (period)
     state2 <= 1'b1;
   else if (fin)
     state2<=1'b0;
     
     
 //------- Registro de espera
 reg [7:0] delay_r = 0;
 
 always @(posedge clk)
   if (load)
     delay_r <= pos_r;
     
 //--- Carga del registro de espera en el arranque
 reg q0 = 0;
 
 always @(posedge clk)
   q0 <= state2;
   
 wire load = (~q0 & state2);  
 
 //-- La señal de busy es el estado
 wire busy = state2;
 
 //------------------------------ Corazon de micro-segundos
 
 localparam US = 10;
 
 //-- Constante para dividir y obtener una frec. de 1Mhz
 localparam M = 12*US;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Cable de reset para el contador
 wire reset;
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 wire ov = (divcounter == M-1);
 
 //-- Comparador que resetea el contador cuando se alcanza el tope
 assign reset = ov | (state2 == 0);
 
 //-- La salida es la señal de overflow
 wire heart_usec_o = ov;
 
 //------------------- Contador de tiempo (unidades de 10-usec)
 
 reg [7:0] tiempo = 0;
 
 always @(posedge clk)
   if (!state2)
     tiempo <= 0;
   else
     if (heart_usec_o)
       tiempo <= tiempo + 1;
       
 //------------- Comparador
 
 //-- Cuando se alcanza el tiempo se emite la señal de fin
 wire fin = (delay_r == tiempo);
 
 
 //--------------------- Generador del periodo
 
 //-- Constante para dividir y obtener una frecuencia de 1KHz
 localparam M2 = 12000*MS;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N2 = $clog2(M2);
 
 //-- Cable de reset para el contador
 wire reset2;
 
 //-- Registro del divisor
 reg [N2-1:0] divcounter2;
 
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset2)
     divcounter2 <= 0;
   else
     divcounter2 <= divcounter2 + 1;
 
 wire ov2 = (divcounter2 == M2-1);
 
 //-- Comparador que resetea el contador cuando se alcanza el tope
 assign reset2 = ov2 | (state == 0);
 
 //-- La salida es la señal de overflow
 wire period = ov2;
 
 //----------- Biestable final de salida
 reg q3 = 0;
 always @(posedge clk)
   q3 <= busy;
 
 assign pwm = q3;
 
 
 
 
endmodule
//---- Top entity
module vd1a52e (
 input [7:0] v2a1cbe,
 input [7:0] v9d7ae8,
 input v2d3366,
 output [7:0] v9d2a6a
);
 wire [0:3] w0;
 wire [0:7] w1;
 wire [0:7] w2;
 wire [0:7] w3;
 wire [0:3] w4;
 wire [0:3] w5;
 wire [0:3] w6;
 wire [0:3] w7;
 wire w8;
 wire w9;
 wire [0:3] w10;
 assign v9d2a6a = w1;
 assign w2 = v2a1cbe;
 assign w3 = v9d7ae8;
 assign w8 = v2d3366;
 assign w9 = v2d3366;
 assign w9 = w8;
 v952eda v54aed2 (
  .v6833fd(w0),
  .v54ac99(w7),
  .v2d3366(w9),
  .ve2616d(w10)
 );
 vafb28f v117a88 (
  .v3c88fc(w0),
  .va9ac17(w1),
  .v515fe7(w4)
 );
 v6bdcd9 v9f32ae (
  .vcc8c7c(w2),
  .v651522(w5),
  .v2cc41f(w7)
 );
 v6bdcd9 v9881c7 (
  .vcc8c7c(w3),
  .v651522(w6),
  .v2cc41f(w10)
 );
 v952eda v34a43a (
  .v6833fd(w4),
  .v54ac99(w5),
  .ve2616d(w6),
  .v2d3366(w8)
 );
endmodule

//---------------------------------------------------
//-- 8-bits-Mux-2-1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 2-to-1 Multplexer (8-bit channels)
//---------------------------------------------------
//---- Top entity
module v952eda (
 input [3:0] v54ac99,
 input [3:0] ve2616d,
 input v2d3366,
 output [3:0] v6833fd
);
 wire w0;
 wire w1;
 wire w2;
 wire [0:3] w3;
 wire w4;
 wire [0:3] w5;
 wire [0:3] w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 assign v6833fd = w3;
 assign w5 = ve2616d;
 assign w6 = v54ac99;
 assign w9 = v2d3366;
 assign w10 = v2d3366;
 assign w11 = v2d3366;
 assign w12 = v2d3366;
 assign w10 = w9;
 assign w11 = w9;
 assign w11 = w10;
 assign w12 = w9;
 assign w12 = w10;
 assign w12 = w11;
 vd0c4e5 v6d94c9 (
  .v030ad0(w0),
  .v2d3366(w11),
  .v27dec4(w15),
  .vb192d0(w17)
 );
 vd0c4e5 vebe465 (
  .v030ad0(w1),
  .v2d3366(w12),
  .v27dec4(w16),
  .vb192d0(w18)
 );
 vd0c4e5 ve1c21f (
  .v030ad0(w2),
  .v2d3366(w10),
  .v27dec4(w13),
  .vb192d0(w14)
 );
 v84f0a1 va44bdf (
  .vee8a83(w0),
  .v03aaf0(w1),
  .vf8041d(w2),
  .v11bca5(w3),
  .vd84a57(w4)
 );
 vd0c4e5 v2ebff3 (
  .v030ad0(w4),
  .v27dec4(w7),
  .vb192d0(w8),
  .v2d3366(w9)
 );
 vc4f23a v3c3a57 (
  .v985fcb(w5),
  .v4f1fd3(w8),
  .vda577d(w14),
  .v3f8943(w17),
  .v64d863(w18)
 );
 vc4f23a vd6d480 (
  .v985fcb(w6),
  .v4f1fd3(w7),
  .vda577d(w13),
  .v3f8943(w15),
  .v64d863(w16)
 );
endmodule

//---------------------------------------------------
//-- 4-bits-Mux-2-1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 2-to-1 Multplexer (4-bit channels)
//---------------------------------------------------
//---- Top entity
module vd0c4e5 (
 input v27dec4,
 input vb192d0,
 input v2d3366,
 output v030ad0
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 assign v030ad0 = w0;
 assign w2 = v2d3366;
 assign w3 = v2d3366;
 assign w6 = v27dec4;
 assign w7 = vb192d0;
 assign w3 = w2;
 v873425 vaaee1f (
  .vcbab45(w0),
  .v0e28cb(w1),
  .v3ca442(w4)
 );
 vba518e v569873 (
  .vcbab45(w1),
  .v3ca442(w2),
  .v0e28cb(w6)
 );
 v3676a0 v1f00ae (
  .v0e28cb(w3),
  .vcbab45(w5)
 );
 vba518e vc8527f (
  .vcbab45(w4),
  .v3ca442(w5),
  .v0e28cb(w7)
 );
endmodule

//---------------------------------------------------
//-- Mux-2-1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 2-to-1 Multplexer (1-bit channels)
//---------------------------------------------------
//---- Top entity
module v873425 (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 v873425_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- OR2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- OR2: Two bits input OR gate
//---------------------------------------------------

module v873425_vf4938a (
 input a,
 input b,
 output c
);
 //-- OR Gate
 //-- Verilog implementation
 
 assign c = a | b;
 
 
endmodule
//---- Top entity
module vba518e (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vba518e_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Two bits input And gate
//---------------------------------------------------

module vba518e_vf4938a (
 input a,
 input b,
 output c
);
 //-- AND gate
 //-- Verilog implementation
 
 assign c = a & b;
 
endmodule
//---- Top entity
module v3676a0 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v3676a0_vd54ca1 vd54ca1 (
  .a(w0),
  .q(w1)
 );
endmodule

//---------------------------------------------------
//-- NOT
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- NOT gate (Verilog implementation)
//---------------------------------------------------

module v3676a0_vd54ca1 (
 input a,
 output q
);
 //-- NOT Gate
 assign q = ~a;
 
 
endmodule
//---- Top entity
module v84f0a1 (
 input vd84a57,
 input vf8041d,
 input vee8a83,
 input v03aaf0,
 output [3:0] v11bca5
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:3] w4;
 assign w0 = vee8a83;
 assign w1 = v03aaf0;
 assign w2 = vf8041d;
 assign w3 = vd84a57;
 assign v11bca5 = w4;
 v84f0a1_v9a2a06 v9a2a06 (
  .i1(w0),
  .i0(w1),
  .i2(w2),
  .i3(w3),
  .o(w4)
 );
endmodule

//---------------------------------------------------
//-- Bus4-Join-all
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Bus4-Join-all: Join all the wires into a 4-bits Bus
//---------------------------------------------------

module v84f0a1_v9a2a06 (
 input i3,
 input i2,
 input i1,
 input i0,
 output [3:0] o
);
 assign o = {i3, i2, i1, i0};
 
endmodule
//---- Top entity
module vc4f23a (
 input [3:0] v985fcb,
 output v4f1fd3,
 output vda577d,
 output v3f8943,
 output v64d863
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:3] w4;
 assign v3f8943 = w0;
 assign v64d863 = w1;
 assign vda577d = w2;
 assign v4f1fd3 = w3;
 assign w4 = v985fcb;
 vc4f23a_v9a2a06 v9a2a06 (
  .o1(w0),
  .o0(w1),
  .o2(w2),
  .o3(w3),
  .i(w4)
 );
endmodule

//---------------------------------------------------
//-- Bus4-Split-all
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Bus4-Split-all: Split the 4-bits bus into its wires
//---------------------------------------------------

module vc4f23a_v9a2a06 (
 input [3:0] i,
 output o3,
 output o2,
 output o1,
 output o0
);
 assign o3 = i[3];
 assign o2 = i[2];
 assign o1 = i[1];
 assign o0 = i[0];
endmodule
//---- Top entity
module vafb28f (
 input [3:0] v515fe7,
 input [3:0] v3c88fc,
 output [7:0] va9ac17
);
 wire [0:7] w0;
 wire [0:3] w1;
 wire [0:3] w2;
 assign va9ac17 = w0;
 assign w1 = v515fe7;
 assign w2 = v3c88fc;
 vafb28f_v9a2a06 v9a2a06 (
  .o(w0),
  .i1(w1),
  .i0(w2)
 );
endmodule

//---------------------------------------------------
//-- Bus8-Join-half
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Bus8-Join-half: Join the two same halves into an 8-bits Bus
//---------------------------------------------------

module vafb28f_v9a2a06 (
 input [3:0] i1,
 input [3:0] i0,
 output [7:0] o
);
 assign o = {i1, i0};
 
endmodule
//---- Top entity
module v6bdcd9 (
 input [7:0] vcc8c7c,
 output [3:0] v651522,
 output [3:0] v2cc41f
);
 wire [0:3] w0;
 wire [0:3] w1;
 wire [0:7] w2;
 assign v651522 = w0;
 assign v2cc41f = w1;
 assign w2 = vcc8c7c;
 v6bdcd9_v9a2a06 v9a2a06 (
  .o1(w0),
  .o0(w1),
  .i(w2)
 );
endmodule

//---------------------------------------------------
//-- Bus8-Split-half
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Bus8-Split-half: Split the 8-bits bus into two buses of the same size
//---------------------------------------------------

module v6bdcd9_v9a2a06 (
 input [7:0] i,
 output [3:0] o1,
 output [3:0] o0
);
 assign o1 = i[7:4];
 assign o0 = i[3:0];
endmodule
//---- Top entity
module va20433 #(
 parameter v71e305 = 0
) (
 input va4102a,
 input vf54559,
 output ve8318d
);
 localparam p3 = v71e305;
 wire w0;
 wire w1;
 wire w2;
 assign w0 = va4102a;
 assign w1 = vf54559;
 assign ve8318d = w2;
 va20433_vb8adf8 #(
  .INI(p3)
 ) vb8adf8 (
  .clk(w0),
  .T(w1),
  .q(w2)
 );
endmodule

//---------------------------------------------------
//-- Biestable-T
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Biestable de cambio (Tipo T). Cuando se recibe un tic cambia de estado
//---------------------------------------------------

module va20433_vb8adf8 #(
 parameter INI = 0
) (
 input clk,
 input T,
 output q
);
 reg q = INI;
 always @(posedge clk)
   if (T)
     q <= ~q;
endmodule
//---- Top entity
module v5124df #(
 parameter v207e0d = 100
) (
 input v531e20,
 output v8337bc
);
 localparam p2 = v207e0d;
 wire w0;
 wire w1;
 assign v8337bc = w0;
 assign w1 = v531e20;
 v5124df_v94c6d7 #(
  .MS(p2)
 ) v94c6d7 (
  .clk_o(w0),
  .clk(w1)
 );
endmodule

//---------------------------------------------------
//-- Corazon_ms
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Bombear 1 bit con el periodo especificado en el parámetro (en ms). Por defecto el periodo es de 100 ms
//---------------------------------------------------

module v5124df_v94c6d7 #(
 parameter MS = 0
) (
 input clk,
 output clk_o
);
 
 //parameter HZ=1;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000*MS;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 //-- Temporal clock
 reg clk_t = 0;
 
 //-- Se usa un contador modulo M/2 para luego
 //-- pasarlo por un biestable T y dividir la frecuencia
 //-- entre 2, para que el ciclo de trabajo sea del 50%
 always @(posedge clk)
     if (divcounter == M/2) begin
       clk_t <= 1;
       divcounter = 0;
     end 
     else begin
       divcounter <=  divcounter + 1;
       clk_t = 0;
     end 
   
 reg clk_o = 0;  
     
 //-- Biestable T para obtener ciclo de trabajo del 50%
 always @(posedge clk)
   if (clk_t)
     clk_o <= ~clk_o;
 
endmodule
//---- Top entity
module v5ad97e #(
 parameter vc5c8ea = 0
) (
 output [7:0] v26dbdb
);
 localparam p0 = vc5c8ea;
 wire [0:7] w1;
 assign v26dbdb = w1;
 v5ad97e_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- Constante-8bits
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Valor genérico constante, de 8 bits. Su valor se introduce como parámetro. Por defecto vale 0
//---------------------------------------------------

module v5ad97e_v465065 #(
 parameter VALUE = 0
) (
 output [7:0] k
);
 assign k = VALUE;
endmodule
//---- Top entity
module v725b7e (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 v725b7e_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

//---------------------------------------------------
//-- 1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Un bit constante a 1
//---------------------------------------------------

module v725b7e_vb2eccd (
 output q
);
 //-- Bit constante a 1
 assign q = 1'b1;
 
 
endmodule
//---- Top entity
module v3046c7 #(
 parameter vfb06ae = 10
) (
 input vac0eb2,
 output v2a8434
);
 localparam p2 = vfb06ae;
 wire w0;
 wire w1;
 assign v2a8434 = w0;
 assign w1 = vac0eb2;
 v3046c7_v6cac2f #(
  .TICS(p2)
 ) v6cac2f (
  .o(w0),
  .clk(w1)
 );
endmodule

//---------------------------------------------------
//-- Corazon-tics
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Corazón de bombeo de tics, cuyo periodo está especificado en tics también
//---------------------------------------------------

module v3046c7_v6cac2f #(
 parameter TICS = 0
) (
 input clk,
 output o
);
 
 
 //-- Los TICs son directamente el módulo del contador
 localparam M = TICS;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Cable de reset para el contador
 wire reset;
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 //-- Comparador que resetea el contador cuando se alcanza el tope
 assign reset = (divcounter == M-1);
 
 //-- La salida es la señal de overflow
 assign o = reset;
 
 
 
 
endmodule
